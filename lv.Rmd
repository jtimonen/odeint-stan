---
title: "Custom ODE solvers in Stan"
author: "Juho Timonen"
date: "3/12/2020"
output: 
  html_vignette:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The R functions and `.stan` files used in this vignette can be found [here](https://github.com/jtimonen/odeint-stan).

```{r libs, results=FALSE, warning=FALSE, message=FALSE}
require(rstan)
source('functions.R')
rstan_options(auto_write = TRUE)
color_scheme_set("red")
```

## 1. Defining a toy system
Here we study a Lotka-Volterra system 

$$
\frac{d\boldsymbol{x}(t)}{dt} = f \left( \boldsymbol{x}(t), \boldsymbol{\theta}\right)
$$
where
$$
f \left( \boldsymbol{x}, \boldsymbol{\theta} \right) = 
\begin{bmatrix}
 x_1 - \theta_1 x_1 x_2 \\
\theta_1 x_1 x_2- \theta_2 x_2
\end{bmatrix}
$$
with $x_1(0) = 1$ and $x_2(0) = 2$. We create a Stan model and expose its functions to R.
```{r model, cache=TRUE, message=FALSE}
t0    <- 0
y0    <- c(1,2)
model <- stan_model('stan/main.stan')
```
```{r expose}
funs <- expose_stan_functions(model)
print(funs)
```
The `odefun` function implements $f$. Functions `rk45_boost`, `euler` and `rk4` are ODE integration methods that call `odefun` several times.

## 2. ODE solvers
The ODE solvers can now be used as follows
```{r solvers, fig.width=7.2, fig.height=4}
t_out  <- seq(0.05,12,by=0.05)
theta  <- c(1,1)     # parameter values

y_out1 <- odeint(rk45_boost, y0, t0, t_out, theta)
y_out2 <- odeint(euler, y0, t0, t_out, theta, step_size = 0.1)
y_out3 <- odeint(rk4, y0, t0, t_out, theta, step_size = 0.2)
Y_out  <- list(y_out1, y_out2, y_out3)
plot_traj(t_out, Y_out, c(" RK45", "Euler (h=0.1)", " RK4 (h=0.2)")) + scale_color_manual(values=c('gray35', 'firebrick2', 'steelblue3'))
```

The output of RK45 and RK4 are indistinguishable in this case. Euler's method would need a much smaller step size (`h`) to get even close in terms of global error.

## 3. Simulating data
We generate data on which we can test our inference. Noisy observations of **x** are denoted by **y**.
```{r sim, fig.width=7.2, fig.height=3.5}
# Simulation setup
set.seed(123)
t_data <- seq(0.5,12,by=0.5)
theta  <- c(1,1)     # true parameter values
sigma  <- 0.2        # noise std
N      <- length(t_data)
D      <- length(y0)
P      <- length(theta)

# Create and plot data
noise <- matrix(rnorm(n=N*D, sd=sigma), N, D)
Y_data <- odeint(rk45_boost, y0, t0, t_data, theta) + noise
plot_data(t_data, Y_data)
```

## 4. Inference using the built-in RK45 method

Here we fit a model where ODEs are solved using the `integrate_ode_rk45` which is built into Stan and uses the Boost implementation of the RK45 (or Dormandâ€“Prince) method.

### 4.1 Fitting the model
```{r fit1, fig.width=12, fig.height=6, cache=TRUE}
stan_seed <- 321
iter <- 1000
data <- create_stan_data(y0, t_data, Y_data, P, "rk45_boost", 0)
fit  <- sampling(model, data, seed = stan_seed, refresh=0, iter=iter, chains=3)
print(fit)
```

We visualize the 4 chains
```{r diag1, fig.width=7.2, fig.height=5}
plot_chains(fit, ncol=2)
```

We see that one chain was slower than others and spent much of the time doing ode solves with parameters that give a very low log posterior probability (`lp__`).
```{r time1}
print(get_elapsed_time(fit))
```

### 4.2 Visualizing solutions
We visualize the ODE solutions against data.
```{r vis1, fig.width=7.2, fig.height=3.5}
t_hat <- seq(0.05, 15, by=0.05)
THETA <- subsample_theta(fit, 100)
Y_hat <- solutions(data, rk45_boost, THETA, t_hat)
plot_solutions(t_data, Y_data, t_hat, Y_hat, alpha=0.3)
```

We plotted 100 randomly taken solutions, some of which are from warmup.

## 5. Custom RK4 method

Now we fit a model where ODEs are solved using our `rk4` solver with step size 0.1.

### 5.1 Fitting the model
```{r fit2, fig.width=12, fig.height=6, cache=TRUE}
step_size <- 0.1
data <- create_stan_data(y0, t_data, Y_data, P, "rk4", step_size)
fit  <- sampling(model, data, seed = stan_seed, refresh=0, iter=iter, chains=3)
print(fit)
```

We visualize the 4 chains
```{r diag2, fig.width=7.2, fig.height=5}
plot_chains(fit, ncol=2)
```

```{r time2}
print(get_elapsed_time(fit))
```

### 5.2 Visualizing solutions
We visualize the ODE solutions against data.
```{r vis2, fig.width=7.2, fig.height=3.5}
THETA <- subsample_theta(fit, 100)
Y_hat <- solutions(data, rk4, THETA, t_hat, step_size)
plot_solutions(t_data, Y_data, t_hat, Y_hat, alpha=0.3)
```

We again plotted 100 randomly taken solutions, some of which are from warmup.

## sessionInfo
```{r end, fig.width=7.2, fig.height=3.5}
print(sessionInfo())
```
